!function(t,e){"object"==typeof exports?
// CommonJS
module.exports=exports=e():"function"==typeof define&&define.amd?
// AMD
define([],e):
// Global (browser)
t.CryptoJS=e()}(this,function(){
/*globals window, global, require*/
/**
	 * CryptoJS core components.
	 */
var P,W,O,I,U,K,X,l,L,j,t,T,N,e,q,Z,V,G,J,Q,Y,$,t1,r1,i1,n1,o1,s,s1,c1,a1,h1,l1,n,f1,r,d1,u1,o,c,a,h,f,d,i=function(h){var i;
// Native crypto from window (Browser)
// Native crypto import via require (NodeJS)
if("undefined"!=typeof window&&window.crypto&&(i=window.crypto),
// Native crypto in web worker (Browser)
"undefined"!=typeof self&&self.crypto&&(i=self.crypto),!(
// Native crypto from global (NodeJS)
i=!(
// Native (experimental IE 11) crypto from window (Browser)
i=!(
// Native crypto from worker
i="undefined"!=typeof globalThis&&globalThis.crypto?globalThis.crypto:i)&&"undefined"!=typeof window&&window.msCrypto?window.msCrypto:i)&&"undefined"!=typeof global&&global.crypto?global.crypto:i)&&"function"==typeof require)try{i=require("crypto")}catch(t){}
/*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */var r=Object.create||function(t){return e.prototype=t,t=new e,e.prototype=null,t};
/*
	     * Local polyfill of Object.create

	     */function e(){}
/**
	     * CryptoJS namespace.
	     */
var t={},n=t.lib={},o=n.Base={
/**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
extend:function(t){
// Spawn
var e=r(this);
// Augment
return t&&e.mixIn(t),
// Create default initializer
e.hasOwnProperty("init")&&this.init!==e.init||(e.init=function(){e.$super.init.apply(this,arguments)}),
// Reference supertype
(
// Initializer's prototype is the subtype object
e.init.prototype=e).$super=this,e},
/**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
create:function(){var t=this.extend();return t.init.apply(t,arguments),t},
/**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
init:function(){},
/**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
mixIn:function(t){for(var e in t)t.hasOwnProperty(e)&&(this[e]=t[e]);
// IE won't copy toString using the loop above
t.hasOwnProperty("toString")&&(this.toString=t.toString)},
/**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
clone:function(){return this.init.prototype.extend(this)}},l=n.WordArray=o.extend({
/**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
init:function(t,e){t=this.words=t||[],this.sigBytes=null!=e?e:4*t.length},
/**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
toString:function(t){return(t||c).stringify(this)},
/**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
concat:function(t){
// Shortcuts
var e=this.words,r=t.words,i=this.sigBytes,n=t.sigBytes;
// Concat
if(
// Clamp excess bits
this.clamp(),i%4)
// Copy one byte at a time
for(var o=0;o<n;o++){var s=r[o>>>2]>>>24-o%4*8&255;e[i+o>>>2]|=s<<24-(i+o)%4*8}else
// Copy one word at a time
for(var c=0;c<n;c+=4)e[i+c>>>2]=r[c>>>2];
// Chainable
return this.sigBytes+=n,this},
/**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
clamp:function(){
// Shortcuts
var t=this.words,e=this.sigBytes;
// Clamp
t[e>>>2]&=4294967295<<32-e%4*8,t.length=h.ceil(e/4)},
/**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
clone:function(){var t=o.clone.call(this);return t.words=this.words.slice(0),t},
/**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
random:function(t){for(var e=[],r=0;r<t;r+=4)e.push(function(){if(i){
// Use getRandomValues method (Browser)
if("function"==typeof i.getRandomValues)try{return i.getRandomValues(new Uint32Array(1))[0]}catch(t){}
// Use randomBytes method (NodeJS)
if("function"==typeof i.randomBytes)try{return i.randomBytes(4).readInt32LE()}catch(t){}}throw new Error("Native crypto module could not be used to get secure random number.")}());return new l.init(e,t)}}),s=t.enc={},c=s.Hex={
/**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
stringify:function(t){for(
// Shortcuts
var e=t.words,r=t.sigBytes,i=[],n=0;n<r;n++){var o=e[n>>>2]>>>24-n%4*8&255;i.push((o>>>4).toString(16)),i.push((15&o).toString(16))}return i.join("")},
/**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
parse:function(t){for(
// Shortcut
var e=t.length,r=[],i=0
// Convert
;i<e;i+=2)r[i>>>3]|=parseInt(t.substr(i,2),16)<<24-i%8*4;return new l.init(r,e/2)}},a=s.Latin1={
/**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
stringify:function(t){for(
// Shortcuts
var e=t.words,r=t.sigBytes,i=[],n=0;n<r;n++){var o=e[n>>>2]>>>24-n%4*8&255;i.push(String.fromCharCode(o))}return i.join("")},
/**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
parse:function(t){for(
// Shortcut
var e=t.length,r=[],i=0
// Convert
;i<e;i++)r[i>>>2]|=(255&t.charCodeAt(i))<<24-i%4*8;return new l.init(r,e)}},f=s.Utf8={
/**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
stringify:function(t){try{return decodeURIComponent(escape(a.stringify(t)))}catch(t){throw new Error("Malformed UTF-8 data")}},
/**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
parse:function(t){return a.parse(unescape(encodeURIComponent(t)))}},d=n.BufferedBlockAlgorithm=o.extend({
/**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
reset:function(){
// Initial values
this._data=new l.init,this._nDataBytes=0},
/**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
_append:function(t){
// Convert string to WordArray, else assume WordArray already
"string"==typeof t&&(t=f.parse(t)),
// Append
this._data.concat(t),this._nDataBytes+=t.sigBytes},
/**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
_process:function(t){var e,r=this._data,i=r.words,n=r.sigBytes,o=this.blockSize,s=n/(4*o),c=(s=t?h.ceil(s):h.max((0|s)-this._minBufferSize,0))*o,t=h.min(4*c,n);
// Shortcuts
// Process blocks
if(c){for(var a=0;a<c;a+=o)
// Perform concrete-algorithm logic
this._doProcessBlock(i,a);
// Remove processed words
e=i.splice(0,c),r.sigBytes-=t}
// Return processed words
return new l.init(e,t)},
/**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
clone:function(){var t=o.clone.call(this);return t._data=this._data.clone(),t},_minBufferSize:0}),u=(n.Hasher=d.extend({
/**
	         * Configuration options.
	         */
cfg:o.extend(),
/**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
init:function(t){
// Apply config defaults
this.cfg=this.cfg.extend(t),
// Set initial values
this.reset()},
/**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
reset:function(){
// Reset data buffer
d.reset.call(this),
// Perform concrete-hasher logic
this._doReset()},
/**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
update:function(t){
// Chainable
// Append
return this._append(t),
// Update the hash
this._process(),this},
/**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
finalize:function(t){
// Final message update
return t&&this._append(t),this._doFinalize()},blockSize:16,
/**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
_createHelper:function(r){return function(t,e){return new r.init(e).finalize(t)}},
/**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
_createHmacHelper:function(r){return function(t,e){return new u.HMAC.init(r,e).finalize(t)}}}),t.algo={});
/**
	     * Library namespace.
	     */return t}(Math),u=(u=(p=i).lib,P=u.Base,W=u.WordArray,(u=p.x64={}).Word=P.extend({
/**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */
init:function(t,e){this.high=t,this.low=e}
/**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */
// not: function () {
// var high = ~this.high;
// var low = ~this.low;
// return X64Word.create(high, low);
// },
/**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */
// and: function (word) {
// var high = this.high & word.high;
// var low = this.low & word.low;
// return X64Word.create(high, low);
// },
/**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */
// or: function (word) {
// var high = this.high | word.high;
// var low = this.low | word.low;
// return X64Word.create(high, low);
// },
/**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */
// xor: function (word) {
// var high = this.high ^ word.high;
// var low = this.low ^ word.low;
// return X64Word.create(high, low);
// },
/**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */
// shiftL: function (n) {
// if (n < 32) {
// var high = (this.high << n) | (this.low >>> (32 - n));
// var low = this.low << n;
// } else {
// var high = this.low << (n - 32);
// var low = 0;
// }
// return X64Word.create(high, low);
// },
/**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */
// shiftR: function (n) {
// if (n < 32) {
// var low = (this.low >>> n) | (this.high << (32 - n));
// var high = this.high >>> n;
// } else {
// var low = this.high >>> (n - 32);
// var high = 0;
// }
// return X64Word.create(high, low);
// },
/**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */
// rotL: function (n) {
// return this.shiftL(n).or(this.shiftR(64 - n));
// },
/**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */
// rotR: function (n) {
// return this.shiftR(n).or(this.shiftL(64 - n));
// },
/**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */
// add: function (word) {
// var low = (this.low + word.low) | 0;
// var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
// var high = (this.high + word.high + carry) | 0;
// return X64Word.create(high, low);
// }
}),u.WordArray=P.extend({
/**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */
init:function(t,e){t=this.words=t||[],this.sigBytes=null!=e?e:8*t.length},
/**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */
toX32:function(){for(
// Shortcuts
var t=this.words,e=t.length,r=[],i=0;i<e;i++){var n=t[i];r.push(n.high),r.push(n.low)}return W.create(r,this.sigBytes)},
/**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */
clone:function(){for(var t=P.clone.call(this),e=t.words=this.words.slice(0),r=e.length,i=0
// Clone "words" array
;i<r;i++)e[i]=e[i].clone();return t}}),
// Check if typed arrays are supported
"function"==typeof ArrayBuffer&&(p=i.lib.WordArray,O=p.init,(p.init=function(t){
// Handle Uint8Array
if((
// Convert other array views to uint8
t=(
// Convert buffers to uint8
t=t instanceof ArrayBuffer?new Uint8Array(t):t)instanceof Int8Array||"undefined"!=typeof Uint8ClampedArray&&t instanceof Uint8ClampedArray||t instanceof Int16Array||t instanceof Uint16Array||t instanceof Int32Array||t instanceof Uint32Array||t instanceof Float32Array||t instanceof Float64Array?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t)instanceof Uint8Array){for(
// Shortcut
var e=t.byteLength,r=[],i=0
// Extract bytes
;i<e;i++)r[i>>>2]|=t[i]<<24-i%4*8;
// Initialize this word array
O.call(this,r,e)}else
// Else call normal init
O.apply(this,arguments)}).prototype=p),i),p1=u.lib.WordArray;function _1(t){return t<<8&4278255360|t>>>8&16711935}(u=u.enc).Utf16=u.Utf16BE={
/**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
stringify:function(t){for(
// Shortcuts
var e=t.words,r=t.sigBytes,i=[],n=0;n<r;n+=2){var o=e[n>>>2]>>>16-n%4*8&65535;i.push(String.fromCharCode(o))}return i.join("")},
/**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
parse:function(t){for(
// Shortcut
var e=t.length,r=[],i=0
// Convert
;i<e;i++)r[i>>>1]|=t.charCodeAt(i)<<16-i%2*16;return p1.create(r,2*e)}},
/**
	     * UTF-16 LE encoding strategy.
	     */
u.Utf16LE={
/**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
stringify:function(t){for(
// Shortcuts
var e=t.words,r=t.sigBytes,i=[],n=0;n<r;n+=2){var o=_1(e[n>>>2]>>>16-n%4*8&65535);i.push(String.fromCharCode(o))}return i.join("")},
/**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
parse:function(t){for(
// Shortcut
var e=t.length,r=[],i=0
// Convert
;i<e;i++)r[i>>>1]|=_1(t.charCodeAt(i)<<16-i%2*16);return p1.create(r,2*e)}},I=(p=i).lib.WordArray,p.enc.Base64={
/**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
stringify:function(t){for(
// Shortcuts
var e=t.words,r=t.sigBytes,i=this._map,n=(
// Clamp excess bits
t.clamp(),[]),o=0;o<r;o+=3)for(var s=(e[o>>>2]>>>24-o%4*8&255)<<16|(e[o+1>>>2]>>>24-(o+1)%4*8&255)<<8|e[o+2>>>2]>>>24-(o+2)%4*8&255,c=0;c<4&&o+.75*c<r;c++)n.push(i.charAt(s>>>6*(3-c)&63));
// Add padding
var a=i.charAt(64);if(a)for(;n.length%4;)n.push(a);return n.join("")},
/**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
parse:function(t){
// Shortcuts
var e=t.length,r=this._map;if(!(i=this._reverseMap))for(var i=this._reverseMap=[],n=0;n<r.length;n++)i[r.charCodeAt(n)]=n;
// Ignore padding
for(var o,s,c=r.charAt(64),a=(c&&-1!==(c=t.indexOf(c))&&(e=c),t),h=e,l=i,f=[],d=0,u=0;u<h;u++)u%4&&(o=l[a.charCodeAt(u-1)]<<u%4*2,s=l[a.charCodeAt(u)]>>>6-u%4*2,f[d>>>2]|=(o|s)<<24-d%4*8,d++);return I.create(f,d)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="},U=(u=i).lib.WordArray,u.enc.Base64url={
/**
	         * Converts a word array to a Base64url string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @param {boolean} urlSafe Whether to use url safe
	         *
	         * @return {string} The Base64url string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
	         */
stringify:function(t,e=!0){for(
// Shortcuts
var r=t.words,i=t.sigBytes,n=e?this._safe_map:this._map,o=(
// Clamp excess bits
t.clamp(),[]),s=0;s<i;s+=3)for(var c=(r[s>>>2]>>>24-s%4*8&255)<<16|(r[s+1>>>2]>>>24-(s+1)%4*8&255)<<8|r[s+2>>>2]>>>24-(s+2)%4*8&255,a=0;a<4&&s+.75*a<i;a++)o.push(n.charAt(c>>>6*(3-a)&63));
// Add padding
var h=n.charAt(64);if(h)for(;o.length%4;)o.push(h);return o.join("")},
/**
	         * Converts a Base64url string to a word array.
	         *
	         * @param {string} base64Str The Base64url string.
	         *
	         * @param {boolean} urlSafe Whether to use url safe
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
	         */
parse:function(t,e=!0){
// Shortcuts
var r=t.length,i=e?this._safe_map:this._map;if(!(n=this._reverseMap))for(var n=this._reverseMap=[],o=0;o<i.length;o++)n[i.charCodeAt(o)]=o;
// Ignore padding
for(var s,c,e=i.charAt(64),a=(e&&-1!==(e=t.indexOf(e))&&(r=e),t),h=r,l=n,f=[],d=0,u=0;u<h;u++)u%4&&(s=l[a.charCodeAt(u-1)]<<u%4*2,c=l[a.charCodeAt(u)]>>>6-u%4*2,f[d>>>2]|=(s|c)<<24-d%4*8,d++);return U.create(f,d)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",_safe_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"};for(var y1=Math,p=i,g1=(u=p.lib).WordArray,v1=u.Hasher,u=p.algo,A=[],B1=0;B1<64;B1++)A[B1]=4294967296*y1.abs(y1.sin(B1+1))|0;function H(t,e,r,i,n,o,s){t=t+(e&r|~e&i)+n+s;return(t<<o|t>>>32-o)+e}function z(t,e,r,i,n,o,s){t=t+(e&i|r&~i)+n+s;return(t<<o|t>>>32-o)+e}function C(t,e,r,i,n,o,s){t=t+(e^r^i)+n+s;return(t<<o|t>>>32-o)+e}function D(t,e,r,i,n,o,s){t=t+(r^(e|~i))+n+s;return(t<<o|t>>>32-o)+e}
/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */u=u.MD5=v1.extend({_doReset:function(){this._hash=new g1.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(t,e){
// Swap endian
for(var r=0;r<16;r++){
// Shortcuts
var i=e+r,n=t[i];t[i]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8)}
// Shortcuts
var o=this._hash.words,s=t[e+0],c=t[e+1],a=t[e+2],h=t[e+3],l=t[e+4],f=t[e+5],d=t[e+6],u=t[e+7],p=t[e+8],_=t[e+9],y=t[e+10],g=t[e+11],v=t[e+12],B=t[e+13],w=t[e+14],k=t[e+15],
// Computation
m=H(o[0],b=o[1],x=o[2],S=o[3],s,7,A[0]),S=H(S,m,b,x,c,12,A[1]),x=H(x,S,m,b,a,17,A[2]),b=H(b,x,S,m,h,22,A[3]);m=H(m,b,x,S,l,7,A[4]),S=H(S,m,b,x,f,12,A[5]),x=H(x,S,m,b,d,17,A[6]),b=H(b,x,S,m,u,22,A[7]),m=H(m,b,x,S,p,7,A[8]),S=H(S,m,b,x,_,12,A[9]),x=H(x,S,m,b,y,17,A[10]),b=H(b,x,S,m,g,22,A[11]),m=H(m,b,x,S,v,7,A[12]),S=H(S,m,b,x,B,12,A[13]),x=H(x,S,m,b,w,17,A[14]),m=z(m,b=H(b,x,S,m,k,22,A[15]),x,S,c,5,A[16]),S=z(S,m,b,x,d,9,A[17]),x=z(x,S,m,b,g,14,A[18]),b=z(b,x,S,m,s,20,A[19]),m=z(m,b,x,S,f,5,A[20]),S=z(S,m,b,x,y,9,A[21]),x=z(x,S,m,b,k,14,A[22]),b=z(b,x,S,m,l,20,A[23]),m=z(m,b,x,S,_,5,A[24]),S=z(S,m,b,x,w,9,A[25]),x=z(x,S,m,b,h,14,A[26]),b=z(b,x,S,m,p,20,A[27]),m=z(m,b,x,S,B,5,A[28]),S=z(S,m,b,x,a,9,A[29]),x=z(x,S,m,b,u,14,A[30]),m=C(m,b=z(b,x,S,m,v,20,A[31]),x,S,f,4,A[32]),S=C(S,m,b,x,p,11,A[33]),x=C(x,S,m,b,g,16,A[34]),b=C(b,x,S,m,w,23,A[35]),m=C(m,b,x,S,c,4,A[36]),S=C(S,m,b,x,l,11,A[37]),x=C(x,S,m,b,u,16,A[38]),b=C(b,x,S,m,y,23,A[39]),m=C(m,b,x,S,B,4,A[40]),S=C(S,m,b,x,s,11,A[41]),x=C(x,S,m,b,h,16,A[42]),b=C(b,x,S,m,d,23,A[43]),m=C(m,b,x,S,_,4,A[44]),S=C(S,m,b,x,v,11,A[45]),x=C(x,S,m,b,k,16,A[46]),m=D(m,b=C(b,x,S,m,a,23,A[47]),x,S,s,6,A[48]),S=D(S,m,b,x,u,10,A[49]),x=D(x,S,m,b,w,15,A[50]),b=D(b,x,S,m,f,21,A[51]),m=D(m,b,x,S,v,6,A[52]),S=D(S,m,b,x,h,10,A[53]),x=D(x,S,m,b,y,15,A[54]),b=D(b,x,S,m,c,21,A[55]),m=D(m,b,x,S,p,6,A[56]),S=D(S,m,b,x,k,10,A[57]),x=D(x,S,m,b,d,15,A[58]),b=D(b,x,S,m,B,21,A[59]),m=D(m,b,x,S,l,6,A[60]),S=D(S,m,b,x,g,10,A[61]),x=D(x,S,m,b,a,15,A[62]),b=D(b,x,S,m,_,21,A[63]),
// Intermediate hash value
o[0]=o[0]+m|0,o[1]=o[1]+b|0,o[2]=o[2]+x|0,o[3]=o[3]+S|0},_doFinalize:function(){
// Swap endian
for(
// Shortcuts
var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes,n=(
// Add padding
e[i>>>5]|=128<<24-i%32,y1.floor(r/4294967296)),n=(e[15+(64+i>>>9<<4)]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8),e[14+(64+i>>>9<<4)]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8),t.sigBytes=4*(e.length+1),
// Hash final blocks
this._process(),this._hash),o=n.words,s=0;s<4;s++){
// Shortcut
var c=o[s];o[s]=16711935&(c<<8|c>>>24)|4278255360&(c<<24|c>>>8)}
// Return final computed hash
return n},clone:function(){var t=v1.clone.call(this);return t._hash=this._hash.clone(),t}}),p.MD5=v1._createHelper(u),
/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
p.HmacMD5=v1._createHmacHelper(u),u=(p=i).lib,K=u.WordArray,X=u.Hasher,u=p.algo,l=[],u=u.SHA1=X.extend({_doReset:function(){this._hash=new K.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(t,e){
// Computation
for(
// Shortcut
var r=this._hash.words,i=r[0],n=r[1],o=r[2],s=r[3],c=r[4],a=0
// Working variables
;a<80;a++){l[a]=a<16?0|t[e+a]:(h=l[a-3]^l[a-8]^l[a-14]^l[a-16])<<1|h>>>31;var h=(i<<5|i>>>27)+c+l[a];h+=a<20?1518500249+(n&o|~n&s):a<40?1859775393+(n^o^s):a<60?(n&o|n&s|o&s)-1894007588:(n^o^s)-899497514,c=s,s=o,o=n<<30|n>>>2,n=i,i=h}
// Intermediate hash value
r[0]=r[0]+i|0,r[1]=r[1]+n|0,r[2]=r[2]+o|0,r[3]=r[3]+s|0,r[4]=r[4]+c|0},_doFinalize:function(){
// Shortcuts
var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;
// Return final computed hash
// Add padding
return e[i>>>5]|=128<<24-i%32,e[14+(64+i>>>9<<4)]=Math.floor(r/4294967296),e[15+(64+i>>>9<<4)]=r,t.sigBytes=4*e.length,
// Hash final blocks
this._process(),this._hash},clone:function(){var t=X.clone.call(this);return t._hash=this._hash.clone(),t}}),
/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
p.SHA1=X._createHelper(u),
/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
p.HmacSHA1=X._createHmacHelper(u);var w1=Math,p=i,k1=(u=p.lib).WordArray,m1=u.Hasher,u=p.algo,S1=[],x1=[];function b1(t){return 4294967296*(t-(0|t))|0}for(var A1=2,H1=0;H1<64;)!function(t){for(var e=w1.sqrt(t),r=2;r<=e;r++)if(!(t%r))return;return 1}(A1)||(H1<8&&(S1[H1]=b1(w1.pow(A1,.5))),x1[H1]=b1(w1.pow(A1,1/3)),H1++),A1++;
// Reusable object
var _=[],u=u.SHA256=m1.extend({_doReset:function(){this._hash=new k1.init(S1.slice(0))},_doProcessBlock:function(t,e){
// Computation
for(
// Shortcut
var r=this._hash.words,i=r[0],n=r[1],o=r[2],s=r[3],c=r[4],a=r[5],h=r[6],l=r[7],f=0
// Working variables
;f<64;f++){_[f]=f<16?0|t[e+f]:(((d=_[f-15])<<25|d>>>7)^(d<<14|d>>>18)^d>>>3)+_[f-7]+(((d=_[f-2])<<15|d>>>17)^(d<<13|d>>>19)^d>>>10)+_[f-16];var d=i&n^i&o^n&o,u=l+((c<<26|c>>>6)^(c<<21|c>>>11)^(c<<7|c>>>25))+(c&a^~c&h)+x1[f]+_[f],l=h,h=a,a=c,c=s+u|0,s=o,o=n,n=i,i=u+(((i<<30|i>>>2)^(i<<19|i>>>13)^(i<<10|i>>>22))+d)|0}
// Intermediate hash value
r[0]=r[0]+i|0,r[1]=r[1]+n|0,r[2]=r[2]+o|0,r[3]=r[3]+s|0,r[4]=r[4]+c|0,r[5]=r[5]+a|0,r[6]=r[6]+h|0,r[7]=r[7]+l|0},_doFinalize:function(){
// Shortcuts
var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;
// Return final computed hash
// Add padding
return e[i>>>5]|=128<<24-i%32,e[14+(64+i>>>9<<4)]=w1.floor(r/4294967296),e[15+(64+i>>>9<<4)]=r,t.sigBytes=4*e.length,
// Hash final blocks
this._process(),this._hash},clone:function(){var t=m1.clone.call(this);return t._hash=this._hash.clone(),t}}),p=(
/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
p.SHA256=m1._createHelper(u),
/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
p.HmacSHA256=m1._createHmacHelper(u),L=(p=i).lib.WordArray,u=p.algo,j=u.SHA256,u=u.SHA224=j.extend({_doReset:function(){this._hash=new L.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var t=j._doFinalize.call(this);return t.sigBytes-=4,t}}),
/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */
p.SHA224=j._createHelper(u),
/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */
p.HmacSHA224=j._createHmacHelper(u),i),z1=p.lib.Hasher,y=(u=p.x64).Word,C1=u.WordArray,u=p.algo;
/**
	     * SHA-256 hash algorithm.
	     */function g(){return y.create.apply(y,arguments)}
// Constants
for(var D1=[g(1116352408,3609767458),g(1899447441,602891725),g(3049323471,3964484399),g(3921009573,2173295548),g(961987163,4081628472),g(1508970993,3053834265),g(2453635748,2937671579),g(2870763221,3664609560),g(3624381080,2734883394),g(310598401,1164996542),g(607225278,1323610764),g(1426881987,3590304994),g(1925078388,4068182383),g(2162078206,991336113),g(2614888103,633803317),g(3248222580,3479774868),g(3835390401,2666613458),g(4022224774,944711139),g(264347078,2341262773),g(604807628,2007800933),g(770255983,1495990901),g(1249150122,1856431235),g(1555081692,3175218132),g(1996064986,2198950837),g(2554220882,3999719339),g(2821834349,766784016),g(2952996808,2566594879),g(3210313671,3203337956),g(3336571891,1034457026),g(3584528711,2466948901),g(113926993,3758326383),g(338241895,168717936),g(666307205,1188179964),g(773529912,1546045734),g(1294757372,1522805485),g(1396182291,2643833823),g(1695183700,2343527390),g(1986661051,1014477480),g(2177026350,1206759142),g(2456956037,344077627),g(2730485921,1290863460),g(2820302411,3158454273),g(3259730800,3505952657),g(3345764771,106217008),g(3516065817,3606008344),g(3600352804,1432725776),g(4094571909,1467031594),g(275423344,851169720),g(430227734,3100823752),g(506948616,1363258195),g(659060556,3750685593),g(883997877,3785050280),g(958139571,3318307427),g(1322822218,3812723403),g(1537002063,2003034995),g(1747873779,3602036899),g(1955562222,1575990012),g(2024104815,1125592928),g(2227730452,2716904306),g(2361852424,442776044),g(2428436474,593698344),g(2756734187,3733110249),g(3204031479,2999351573),g(3329325298,3815920427),g(3391569614,3928383900),g(3515267271,566280711),g(3940187606,3454069534),g(4118630271,4000239992),g(116418474,1914138554),g(174292421,2731055270),g(289380356,3203993006),g(460393269,320620315),g(685471733,587496836),g(852142971,1086792851),g(1017036298,365543100),g(1126000580,2618297676),g(1288033470,3409855158),g(1501505948,4234509866),g(1607167915,987167468),g(1816402316,1246189591)],e1=[],E1=0
// Reusable objects
;E1<80;E1++)e1[E1]=g();u=u.SHA512=z1.extend({_doReset:function(){this._hash=new C1.init([new y.init(1779033703,4089235720),new y.init(3144134277,2227873595),new y.init(1013904242,4271175723),new y.init(2773480762,1595750129),new y.init(1359893119,2917565137),new y.init(2600822924,725511199),new y.init(528734635,4215389547),new y.init(1541459225,327033209)])},_doProcessBlock:function(W,O){
// Rounds
for(
// Shortcuts
var t=this._hash.words,e=t[0],r=t[1],i=t[2],n=t[3],o=t[4],s=t[5],c=t[6],t=t[7],I=e.high,a=e.low,U=r.high,h=r.low,K=i.high,l=i.low,X=n.high,f=n.low,L=o.high,d=o.low,j=s.high,u=s.low,T=c.high,p=c.low,N=t.high,_=t.low,y=I,g=a,v=U,B=h,w=K,k=l,q=X,m=f,S=L,x=d,Z=j,b=u,V=T,G=p,J=N,Q=_,A=0;A<80;A++)var H,z,C=e1[A],D=(
// Extend message
A<16?(z=C.high=0|W[O+2*A],H=C.low=0|W[O+2*A+1]):(P=(F=e1[A-15]).high,F=F.low,M=(R=e1[A-2]).high,R=R.low,E=(D=e1[A-7]).high,D=D.low,$=(Y=e1[A-16]).high,z=(z=((P>>>1|F<<31)^(P>>>8|F<<24)^P>>>7)+E+((H=(E=(F>>>1|P<<31)^(F>>>8|P<<24)^(F>>>7|P<<25))+D)>>>0<E>>>0?1:0))+((M>>>19|R<<13)^(M<<3|R>>>29)^M>>>6)+((H+=F=(R>>>19|M<<13)^(R<<3|M>>>29)^(R>>>6|M<<26))>>>0<F>>>0?1:0),H+=P=Y.low,C.high=z=z+$+(H>>>0<P>>>0?1:0),C.low=H),S&Z^~S&V),E=x&b^~x&G,R=y&v^y&w^v&w,M=(g>>>28|y<<4)^(g<<30|y>>>2)^(g<<25|y>>>7),F=D1[A],Y=F.high,$=F.low,P=Q+((x>>>14|S<<18)^(x>>>18|S<<14)^(x<<23|S>>>9)),C=J+((S>>>14|x<<18)^(S>>>18|x<<14)^(S<<23|x>>>9))+(P>>>0<Q>>>0?1:0),t1=M+(g&B^g&k^B&k),
// Update working variables
J=V,Q=G,V=Z,G=b,Z=S,b=x,S=q+(C=C+D+((P=P+E)>>>0<E>>>0?1:0)+Y+((P=P+$)>>>0<$>>>0?1:0)+z+((P=P+H)>>>0<H>>>0?1:0))+((x=m+P|0)>>>0<m>>>0?1:0)|0,q=w,m=k,w=v,k=B,v=y,B=g,y=C+(((y>>>28|g<<4)^(y<<30|g>>>2)^(y<<25|g>>>7))+R+(t1>>>0<M>>>0?1:0))+((g=P+t1|0)>>>0<P>>>0?1:0)|0;
// Intermediate hash value
a=e.low=a+g,e.high=I+y+(a>>>0<g>>>0?1:0),h=r.low=h+B,r.high=U+v+(h>>>0<B>>>0?1:0),l=i.low=l+k,i.high=K+w+(l>>>0<k>>>0?1:0),f=n.low=f+m,n.high=X+q+(f>>>0<m>>>0?1:0),d=o.low=d+x,o.high=L+S+(d>>>0<x>>>0?1:0),u=s.low=u+b,s.high=j+Z+(u>>>0<b>>>0?1:0),p=c.low=p+G,c.high=T+V+(p>>>0<G>>>0?1:0),_=t.low=_+Q,t.high=N+J+(_>>>0<Q>>>0?1:0)},_doFinalize:function(){
// Shortcuts
var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;
// Return final computed hash
// Add padding
return e[i>>>5]|=128<<24-i%32,e[30+(128+i>>>10<<5)]=Math.floor(r/4294967296),e[31+(128+i>>>10<<5)]=r,t.sigBytes=4*e.length,
// Hash final blocks
this._process(),this._hash.toX32()},clone:function(){var t=z1.clone.call(this);return t._hash=this._hash.clone(),t},blockSize:32}),
/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */
p.SHA512=z1._createHelper(u),
/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */
p.HmacSHA512=z1._createHmacHelper(u),u=(p=i).x64,t=u.Word,T=u.WordArray,u=p.algo,N=u.SHA512,u=u.SHA384=N.extend({_doReset:function(){this._hash=new T.init([new t.init(3418070365,3238371032),new t.init(1654270250,914150663),new t.init(2438529370,812702999),new t.init(355462360,4144912697),new t.init(1731405415,4290775857),new t.init(2394180231,1750603025),new t.init(3675008525,1694076839),new t.init(1203062813,3204075428)])},_doFinalize:function(){var t=N._doFinalize.call(this);return t.sigBytes-=16,t}}),
/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */
p.SHA384=N._createHelper(u),
/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */
p.HmacSHA384=N._createHmacHelper(u);for(var R1=Math,p=i,M1=(u=p.lib).WordArray,F1=u.Hasher,P1=p.x64.Word,u=p.algo,W1=[],O1=[],I1=[],v=1,B=0,U1=0;U1<24;U1++){W1[v+5*B]=(U1+1)*(U1+2)/2%64;var K1=(2*v+3*B)%5;v=B%5,B=K1}
// Compute pi index constants
for(v=0;v<5;v++)for(B=0;B<5;B++)O1[v+5*B]=B+(2*v+3*B)%5*5;
// Compute round constants
for(var X1=1,L1=0;L1<24;L1++){for(var j1,T1=0,N1=0,q1=0;q1<7;q1++)1&X1&&((j1=(1<<q1)-1)<32?N1^=1<<j1:T1^=1<<j1-32),
// Compute next LFSR
128&X1?
// Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
X1=X1<<1^113:X1<<=1;I1[L1]=P1.create(T1,N1)}for(
// Reusable objects for temporary values
var E=[],Z1=0;Z1<25;Z1++)E[Z1]=P1.create();function V1(t,e,r){return t&e|~t&r}function G1(t,e,r){return t&r|e&~r}function J1(t,e){return t<<e|t>>>32-e}
/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */function Q1(t){return"string"==typeof t?f1:n}function Y1(t,e,r){var i,n=this._iv;
// Shortcut
// Choose mixing block
n?(i=n,
// Remove IV for subsequent blocks
this._iv=void 0):i=this._prevBlock;
// XOR blocks
for(var o=0;o<r;o++)t[e+o]^=i[o]}function $1(t,e,r,i){var n,o=this._iv;
// Shortcut
// Generate keystream
o?(n=o.slice(0),
// Remove IV for subsequent blocks
this._iv=void 0):n=this._prevBlock,i.encryptBlock(n,0);
// Encrypt
for(var s=0;s<r;s++)t[e+s]^=n[s]}function t2(t){var e,r,i;return 255==(t>>24&255)?(r=t>>8&255,i=255&t,255===(e=t>>16&255)?(e=0,255===r?(r=0,255===i?i=0:++i):++r):++e,t=0,t=(t+=e<<16)+(r<<8)+i):t+=1<<24,t}u=u.SHA3=F1.extend({
/**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */
cfg:F1.cfg.extend({outputLength:512}),_doReset:function(){for(var t=this._state=[],e=0;e<25;e++)t[e]=new P1.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(t,e){
// Absorb
for(
// Shortcuts
var r=this._state,i=this.blockSize/2,n=0;n<i;n++){
// Shortcuts
var o=t[e+2*n],s=t[e+2*n+1],
// Swap endian
o=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8);(m=r[n]).high^=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),m.low^=o}
// Rounds
for(var c=0;c<24;c++){
// Theta
for(var a=0;a<5;a++){for(
// Mix column lanes
var h=0,l=0,f=0;f<5;f++)h^=(m=r[a+5*f]).high,l^=m.low;
// Temporary values
var d=E[a];d.high=h,d.low=l}for(a=0;a<5;a++)for(
// Shortcuts
var u=E[(a+4)%5],p=E[(a+1)%5],_=p.high,p=p.low,h=u.high^(_<<1|p>>>31),l=u.low^(p<<1|_>>>31),f=0;f<5;f++)(m=r[a+5*f]).high^=h,m.low^=l;
// Rho Pi
for(var y=1;y<25;y++){var g=(m=r[y]).high,v=m.low,B=W1[y],g=(
// Rotate lanes
l=B<32?(h=g<<B|v>>>32-B,v<<B|g>>>32-B):(h=v<<B-32|g>>>64-B,g<<B-32|v>>>64-B),E[O1[y]]);g.high=h,g.low=l}
// Rho pi at x = y = 0
var w=E[0],k=r[0];w.high=k.high,w.low=k.low;
// Chi
for(a=0;a<5;a++)for(f=0;f<5;f++){
// Shortcuts
var m=r[y=a+5*f],S=E[y],x=E[(a+1)%5+5*f],b=E[(a+2)%5+5*f];
// Mix rows
m.high=S.high^~x.high&b.high,m.low=S.low^~x.low&b.low}
// Iota
m=r[0],w=I1[c];m.high^=w.high,m.low^=w.low}},_doFinalize:function(){for(
// Shortcuts
var t=this._data,e=t.words,r=(this._nDataBytes,8*t.sigBytes),i=32*this.blockSize,n=(
// Add padding
e[r>>>5]|=1<<24-r%32,e[(R1.ceil((1+r)/i)*i>>>5)-1]|=128,t.sigBytes=4*e.length,
// Hash final blocks
this._process(),this._state),r=this.cfg.outputLength/8,o=r/8,s=[],c=0;c<o;c++){
// Shortcuts
var a=n[c],h=a.high,a=a.low,
// Swap endian
h=16711935&(h<<8|h>>>24)|4278255360&(h<<24|h>>>8);
// Squeeze state to retrieve hash
s.push(16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8)),s.push(h)}
// Return final computed hash
return new M1.init(s,r)},clone:function(){for(var t=F1.clone.call(this),e=t._state=this._state.slice(0),r=0;r<25;r++)e[r]=e[r].clone();return t}}),
/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */
p.SHA3=F1._createHelper(u),
/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */
p.HmacSHA3=F1._createHmacHelper(u),Math,
/** @preserve
	(c) 2012 by CÃ©dric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
u=(p=i).lib,e=u.WordArray,q=u.Hasher,u=p.algo,Z=e.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),V=e.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),G=e.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),J=e.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),Q=e.create([0,1518500249,1859775393,2400959708,2840853838]),Y=e.create([1352829926,1548603684,1836072691,2053994217,0]),u=u.RIPEMD160=q.extend({_doReset:function(){this._hash=e.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(t,e){
// Swap endian
for(var r=0;r<16;r++){
// Shortcuts
var i=e+r,n=t[i];
// Swap
t[i]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8)}
// Shortcut
for(var o,s,c,a,h,l,f=this._hash.words,d=Q.words,u=Y.words,p=Z.words,_=V.words,y=G.words,g=J.words,v=o=f[0],B=s=f[1],w=c=f[2],k=a=f[3],m=h=f[4],r=0;r<80;r+=1)l=(l=J1(l=(l=o+t[e+p[r]]|0)+(r<16?(s^c^a)+d[0]:r<32?V1(s,c,a)+d[1]:r<48?((s|~c)^a)+d[2]:r<64?G1(s,c,a)+d[3]:(s^(c|~a))+d[4])|0,y[r]))+h|0,o=h,h=a,a=J1(c,10),c=s,s=l,l=(l=J1(l=(l=v+t[e+_[r]]|0)+(r<16?(B^(w|~k))+u[0]:r<32?G1(B,w,k)+u[1]:r<48?((B|~w)^k)+u[2]:r<64?V1(B,w,k)+u[3]:(B^w^k)+u[4])|0,g[r]))+m|0,v=m,m=k,k=J1(w,10),w=B,B=l;
// Intermediate hash value
l=f[1]+c+k|0,f[1]=f[2]+a+m|0,f[2]=f[3]+h+v|0,f[3]=f[4]+o+B|0,f[4]=f[0]+s+w|0,f[0]=l},_doFinalize:function(){
// Swap endian
for(
// Shortcuts
var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes,i=(
// Add padding
e[i>>>5]|=128<<24-i%32,e[14+(64+i>>>9<<4)]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8),t.sigBytes=4*(e.length+1),
// Hash final blocks
this._process(),this._hash),n=i.words,o=0;o<5;o++){
// Shortcut
var s=n[o];
// Swap
n[o]=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8)}
// Return final computed hash
return i},clone:function(){var t=q.clone.call(this);return t._hash=this._hash.clone(),t}}),p.RIPEMD160=q._createHelper(u),
/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */
p.HmacRIPEMD160=q._createHmacHelper(u),u=(p=i).lib.Base,$=p.enc.Utf8,p.algo.HMAC=u.extend({
/**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
init:function(t,e){
// Init hasher
t=this._hasher=new t.init,
// Convert string to WordArray, else assume WordArray already
"string"==typeof e&&(e=$.parse(e));
// XOR keys with pad constants
for(
// Shortcuts
var r=t.blockSize,i=4*r,t=(
// Allow arbitrary length keys
// Clamp excess bits
(e=e.sigBytes>i?t.finalize(e):e).clamp(),this._oKey=e.clone()),e=this._iKey=e.clone(),n=t.words,o=e.words,s=0;s<r;s++)n[s]^=1549556828,o[s]^=909522486;t.sigBytes=e.sigBytes=i,
// Set initial values
this.reset()},
/**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
reset:function(){
// Shortcut
var t=this._hasher;
// Reset
t.reset(),t.update(this._iKey)},
/**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
update:function(t){
// Chainable
return this._hasher.update(t),this},
/**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
finalize:function(t){
// Shortcut
var e=this._hasher,t=e.finalize(t);
// Compute HMAC
return e.reset(),e.finalize(this._oKey.clone().concat(t))}}),u=(p=i).lib,w=u.Base,t1=u.WordArray,u=p.algo,F=u.SHA1,r1=u.HMAC,i1=u.PBKDF2=w.extend({
/**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA1
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
cfg:w.extend({keySize:4,hasher:F,iterations:1}),
/**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */
init:function(t){this.cfg=this.cfg.extend(t)},
/**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
compute:function(t,e){
// Generate key
for(
// Shortcut
var r=this.cfg,i=r1.create(r.hasher,t),n=t1.create(),o=t1.create([1]),s=n.words,c=o.words,a=r.keySize,h=r.iterations
// Init HMAC
;s.length<a;){for(var l=i.update(e).finalize(o),f=(i.reset(),l.words),d=f.length,u=l,p=1;p<h;p++){u=i.finalize(u),i.reset();
// XOR intermediate with block
for(
// Shortcut
var _=u.words,y=0;y<d;y++)f[y]^=_[y]}n.concat(l),c[0]++}return n.sigBytes=4*a,n}}),
/**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */
p.PBKDF2=function(t,e,r){return i1.create(r).compute(t,e)},w=(u=i).lib,F=w.Base,n1=w.WordArray,w=u.algo,p=w.MD5,o1=w.EvpKDF=F.extend({
/**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
cfg:F.extend({keySize:4,hasher:p,iterations:1}),
/**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
init:function(t){this.cfg=this.cfg.extend(t)},
/**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
compute:function(t,e){
// Generate key
for(var r,i=this.cfg,n=i.hasher.create(),o=n1.create(),s=o.words,c=i.keySize,a=i.iterations
// Shortcut
;s.length<c;){r&&n.update(r),r=n.update(t).finalize(e),n.reset();
// Iterations
for(var h=1;h<a;h++)r=n.finalize(r),n.reset();o.concat(r)}return o.sigBytes=4*c,o}}),
/**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
u.EvpKDF=function(t,e,r){return o1.create(r).compute(t,e)},
/**
	 * Cipher core components.
	 */
i.lib.Cipher||(F=(w=i).lib,p=F.Base,s=F.WordArray,s1=F.BufferedBlockAlgorithm,(u=w.enc).Utf8,c1=u.Base64,a1=w.algo.EvpKDF,h1=F.Cipher=s1.extend({
/**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
cfg:p.extend(),
/**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
createEncryptor:function(t,e){return this.create(this._ENC_XFORM_MODE,t,e)},
/**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
createDecryptor:function(t,e){return this.create(this._DEC_XFORM_MODE,t,e)},
/**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
init:function(t,e,r){
// Apply config defaults
this.cfg=this.cfg.extend(r),
// Store transform mode and key
this._xformMode=t,this._key=e,
// Set initial values
this.reset()},
/**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
reset:function(){
// Reset data buffer
s1.reset.call(this),
// Perform concrete-cipher logic
this._doReset()},
/**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
process:function(t){
// Process available blocks
// Append
return this._append(t),this._process()},
/**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
finalize:function(t){
// Final data update
return t&&this._append(t),this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,
/**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
_createHelper:function(i){return{encrypt:function(t,e,r){return Q1(e).encrypt(i,t,e,r)},decrypt:function(t,e,r){return Q1(e).decrypt(i,t,e,r)}}}}),F.StreamCipher=h1.extend({_doFinalize:function(){return this._process(!0)},blockSize:1}),u=w.mode={},r=F.BlockCipherMode=p.extend({
/**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
createEncryptor:function(t,e){return this.Encryptor.create(t,e)},
/**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
createDecryptor:function(t,e){return this.Decryptor.create(t,e)},
/**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
init:function(t,e){this._cipher=t,this._iv=e}}),r=u.CBC=(
/**
	         * CBC encryptor.
	         */
(u=r.extend()).Encryptor=u.extend({
/**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
processBlock:function(t,e){
// Shortcuts
var r=this._cipher,i=r.blockSize;
// XOR and encrypt
Y1.call(this,t,e,i),r.encryptBlock(t,e),
// Remember this block to use with next block
this._prevBlock=t.slice(e,e+i)}}),
/**
	         * CBC decryptor.
	         */
u.Decryptor=u.extend({
/**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
processBlock:function(t,e){
// Shortcuts
var r=this._cipher,i=r.blockSize,n=t.slice(e,e+i);
// Decrypt and XOR
r.decryptBlock(t,e),Y1.call(this,t,e,i),
// This block becomes the previous block
this._prevBlock=n}}),u),u=(w.pad={}).Pkcs7={
/**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
pad:function(t,e){for(
// Shortcut
var e=4*e,r=e-t.sigBytes%e,i=r<<24|r<<16|r<<8|r,n=[],o=0
// Count padding bytes
;o<r;o+=4)n.push(i);e=s.create(n,r);
// Add padding
t.concat(e)},
/**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
unpad:function(t){
// Get number of padding bytes from last byte
var e=255&t.words[t.sigBytes-1>>>2];
// Remove padding
t.sigBytes-=e}},F.BlockCipher=h1.extend({
/**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
cfg:h1.cfg.extend({mode:r,padding:u}),reset:function(){
// Reset cipher
h1.reset.call(this);var t,e=this.cfg,r=e.iv,e=e.mode;
// Reset block mode
this._xformMode==this._ENC_XFORM_MODE?t=e.createEncryptor:(t=e.createDecryptor,
// Keep at least one block in the buffer for unpadding
this._minBufferSize=1),this._mode&&this._mode.__creator==t?this._mode.init(this,r&&r.words):(this._mode=t.call(e,this,r&&r.words),this._mode.__creator=t)},_doProcessBlock:function(t,e){this._mode.processBlock(t,e)},_doFinalize:function(){var t,e=this.cfg.padding;
// Shortcut
// Finalize
return this._xformMode==this._ENC_XFORM_MODE?(
// Pad data
e.pad(this._data,this.blockSize),
// Process final blocks
t=this._process(!0)):(
// Process final blocks
t=this._process(!0),
// Unpad data
e.unpad(t)),t},blockSize:4}),l1=F.CipherParams=p.extend({
/**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
init:function(t){this.mixIn(t)},
/**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
toString:function(t){return(t||this.formatter).stringify(this)}}),r=(w.format={}).OpenSSL={
/**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
stringify:function(t){var e=t.ciphertext,t=t.salt,
// Format
t=t?s.create([1398893684,1701076831]).concat(t).concat(e):e;
// Shortcuts
return t.toString(c1)},
/**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
parse:function(t){var e,t=c1.parse(t),r=t.words;
// Parse base64
// Test for salt
return 1398893684==r[0]&&1701076831==r[1]&&(
// Extract salt
e=s.create(r.slice(2,4)),
// Remove salt from ciphertext
r.splice(0,4),t.sigBytes-=16),l1.create({ciphertext:t,salt:e})}},n=F.SerializableCipher=p.extend({
/**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
cfg:p.extend({format:r}),
/**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
encrypt:function(t,e,r,i){
// Apply config defaults
i=this.cfg.extend(i);
// Encrypt
var n=t.createEncryptor(r,i),e=n.finalize(e),n=n.cfg;
// Create and return serializable cipher params
return l1.create({ciphertext:e,key:r,iv:n.iv,algorithm:t,mode:n.mode,padding:n.padding,blockSize:t.blockSize,formatter:i.format})},
/**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
decrypt:function(t,e,r,i){
// Apply config defaults
return i=this.cfg.extend(i),
// Convert string to CipherParams
e=this._parse(e,i.format),t.createDecryptor(r,i).finalize(e.ciphertext)},
/**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
_parse:function(t,e){return"string"==typeof t?e.parse(t,this):t}}),u=(w.kdf={}).OpenSSL={
/**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
execute:function(t,e,r,i){
// Generate random salt
i=i||s.random(8);
// Derive key and IV
t=a1.create({keySize:e+r}).compute(t,i),r=s.create(t.words.slice(e),4*r);
// Separate key and IV
// Return params
return t.sigBytes=4*e,l1.create({key:t,iv:r,salt:i})}},f1=F.PasswordBasedCipher=n.extend({
/**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
cfg:n.cfg.extend({kdf:u}),
/**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
encrypt:function(t,e,r,i){
// Derive key and other params
r=(
// Apply config defaults
i=this.cfg.extend(i)).kdf.execute(r,t.keySize,t.ivSize),
// Add IV to config
i.iv=r.iv,t=n.encrypt.call(this,t,e,r.key,i);
// Mix in derived params
return t.mixIn(r),t},
/**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
decrypt:function(t,e,r,i){
// Apply config defaults
i=this.cfg.extend(i),
// Convert string to CipherParams
e=this._parse(e,i.format);
// Derive key and other params
r=i.kdf.execute(r,t.keySize,t.ivSize,e.salt);
// Add IV to config
return i.iv=r.iv,n.decrypt.call(this,t,e,r.key,i)}})),
/**
	 * Cipher Feedback block mode.
	 */
i.mode.CFB=((p=i.lib.BlockCipherMode.extend()).Encryptor=p.extend({processBlock:function(t,e){
// Shortcuts
var r=this._cipher,i=r.blockSize;$1.call(this,t,e,i,r),
// Remember this block to use with next block
this._prevBlock=t.slice(e,e+i)}}),p.Decryptor=p.extend({processBlock:function(t,e){
// Shortcuts
var r=this._cipher,i=r.blockSize,n=t.slice(e,e+i);$1.call(this,t,e,i,r),
// This block becomes the previous block
this._prevBlock=n}}),p),
/**
	 * Counter block mode.
	 */
i.mode.CTR=(r=i.lib.BlockCipherMode.extend(),w=r.Encryptor=r.extend({processBlock:function(t,e){
// Shortcuts
var r=this._cipher,i=r.blockSize,n=this._iv,o=this._counter,s=(
// Generate keystream
n&&(o=this._counter=n.slice(0),
// Remove IV for subsequent blocks
this._iv=void 0),o.slice(0));r.encryptBlock(s,0),
// Increment counter
o[i-1]=o[i-1]+1|0;
// Encrypt
for(var c=0;c<i;c++)t[e+c]^=s[c]}}),r.Decryptor=w,r),
/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
i.mode.CTRGladman=(F=i.lib.BlockCipherMode.extend(),u=F.Encryptor=F.extend({processBlock:function(t,e){
// Shortcuts
var r=this._cipher,i=r.blockSize,n=this._iv,o=this._counter,s=(
// Generate keystream
n&&(o=this._counter=n.slice(0),
// Remove IV for subsequent blocks
this._iv=void 0),0===((n=o)[0]=t2(n[0]))&&(
// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
n[1]=t2(n[1])),o.slice(0));r.encryptBlock(s,0);
// Encrypt
for(var c=0;c<i;c++)t[e+c]^=s[c]}}),F.Decryptor=u,F),
/**
	 * Output Feedback block mode.
	 */
i.mode.OFB=(p=i.lib.BlockCipherMode.extend(),w=p.Encryptor=p.extend({processBlock:function(t,e){
// Shortcuts
var r=this._cipher,i=r.blockSize,n=this._iv,o=this._keystream;
// Generate keystream
n&&(o=this._keystream=n.slice(0),
// Remove IV for subsequent blocks
this._iv=void 0),r.encryptBlock(o,0);
// Encrypt
for(var s=0;s<i;s++)t[e+s]^=o[s]}}),p.Decryptor=w,p),
/**
	 * Electronic Codebook block mode.
	 */
i.mode.ECB=((u=i.lib.BlockCipherMode.extend()).Encryptor=u.extend({processBlock:function(t,e){this._cipher.encryptBlock(t,e)}}),u.Decryptor=u.extend({processBlock:function(t,e){this._cipher.decryptBlock(t,e)}}),u),
/**
	 * ANSI X.923 padding strategy.
	 */
i.pad.AnsiX923={pad:function(t,e){
// Shortcuts
var r=t.sigBytes,e=4*e,e=e-r%e,r=r+e-1;
// Pad
t.clamp(),t.words[r>>>2]|=e<<24-r%4*8,t.sigBytes+=e},unpad:function(t){
// Get number of padding bytes from last byte
var e=255&t.words[t.sigBytes-1>>>2];
// Remove padding
t.sigBytes-=e}},
/**
	 * ISO 10126 padding strategy.
	 */
i.pad.Iso10126={pad:function(t,e){
// Shortcut
e*=4,e-=t.sigBytes%e;
// Count padding bytes
// Pad
t.concat(i.lib.WordArray.random(e-1)).concat(i.lib.WordArray.create([e<<24],1))},unpad:function(t){
// Get number of padding bytes from last byte
var e=255&t.words[t.sigBytes-1>>>2];
// Remove padding
t.sigBytes-=e}},
/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */
i.pad.Iso97971={pad:function(t,e){
// Add 0x80 byte
t.concat(i.lib.WordArray.create([2147483648],1)),
// Zero pad the rest
i.pad.ZeroPadding.pad(t,e)},unpad:function(t){
// Remove zero padding
i.pad.ZeroPadding.unpad(t),
// Remove one more byte -- the 0x80 byte
t.sigBytes--}},
/**
	 * Zero padding strategy.
	 */
i.pad.ZeroPadding={pad:function(t,e){
// Shortcut
e*=4;
// Pad
t.clamp(),t.sigBytes+=e-(t.sigBytes%e||e)},unpad:function(t){for(
// Shortcut
var e=t.words,r=t.sigBytes-1,r=t.sigBytes-1
// Unpad
;0<=r;r--)if(e[r>>>2]>>>24-r%4*8&255){t.sigBytes=r+1;break}}},
/**
	 * A noop padding strategy.
	 */
i.pad.NoPadding={pad:function(){},unpad:function(){}},d1=(F=i).lib.CipherParams,u1=F.enc.Hex,F.format.Hex={
/**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
stringify:function(t){return t.ciphertext.toString(u1)},
/**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
parse:function(t){t=u1.parse(t);return d1.create({ciphertext:t})}};for(
// Shortcuts
var w=i,p=w.lib.BlockCipher,u=w.algo,k=[],e2=[],r2=[],i2=[],n2=[],o2=[],s2=[],c2=[],a2=[],h2=[],m=[],S=0;S<256;S++)m[S]=S<128?S<<1:S<<1^283;
// Walk GF(2^8)
for(var x=0,b=0,S=0;S<256;S++){
// Compute sbox
var R=b^b<<1^b<<2^b<<3^b<<4,l2=m[e2[k[x]=R=R>>>8^255&R^99]=x],f2=m[l2],d2=m[f2],M=257*m[R]^16843008*R;r2[x]=M<<24|M>>>8,i2[x]=M<<16|M>>>16,n2[x]=M<<8|M>>>24,o2[x]=M,s2[R]=(M=16843009*d2^65537*f2^257*l2^16843008*x)<<24|M>>>8,c2[R]=M<<16|M>>>16,a2[R]=M<<8|M>>>24,h2[R]=M,
// Compute next counter
x?(x=l2^m[m[m[d2^l2]]],b^=m[m[b]]):x=b=1}
// Precomputed Rcon lookup
var u2=[0,1,2,4,8,16,32,64,128,27,54],u=u.AES=p.extend({_doReset:function(){
// Skip reset of nRounds has been set before and key did not change
if(!this._nRounds||this._keyPriorReset!==this._key){for(
// Shortcuts
var t=this._keyPriorReset=this._key,e=t.words,r=t.sigBytes/4,i=4*(1+(this._nRounds=6+r)),n=this._keySchedule=[],o=0;o<i;o++)o<r?n[o]=e[o]:(a=n[o-1],o%r?6<r&&o%r==4&&(
// Sub word
a=k[a>>>24]<<24|k[a>>>16&255]<<16|k[a>>>8&255]<<8|k[255&a]):(
// Rot word
// Sub word
a=k[(a=a<<8|a>>>24)>>>24]<<24|k[a>>>16&255]<<16|k[a>>>8&255]<<8|k[255&a],
// Mix Rcon
a^=u2[o/r|0]<<24),n[o]=n[o-r]^a);
// Compute inv key schedule
for(var s=this._invKeySchedule=[],c=0;c<i;c++){var a,o=i-c;a=c%4?n[o]:n[o-4],s[c]=c<4||o<=4?a:s2[k[a>>>24]]^c2[k[a>>>16&255]]^a2[k[a>>>8&255]]^h2[k[255&a]]}}},encryptBlock:function(t,e){this._doCryptBlock(t,e,this._keySchedule,r2,i2,n2,o2,k)},decryptBlock:function(t,e){
// Swap 2nd and 4th rows
var r=t[e+1],r=(t[e+1]=t[e+3],t[e+3]=r,this._doCryptBlock(t,e,this._invKeySchedule,s2,c2,a2,h2,e2),t[e+1]);t[e+1]=t[e+3],t[e+3]=r},_doCryptBlock:function(t,e,r,i,n,o,s,c){
// Rounds
for(
// Shortcut
var a=this._nRounds,h=t[e]^r[0],l=t[e+1]^r[1],f=t[e+2]^r[2],d=t[e+3]^r[3],u=4,p=1
// Get input, add round key
;p<a;p++)
// Shift rows, sub bytes, mix columns, add round key
var _=i[h>>>24]^n[l>>>16&255]^o[f>>>8&255]^s[255&d]^r[u++],y=i[l>>>24]^n[f>>>16&255]^o[d>>>8&255]^s[255&h]^r[u++],g=i[f>>>24]^n[d>>>16&255]^o[h>>>8&255]^s[255&l]^r[u++],v=i[d>>>24]^n[h>>>16&255]^o[l>>>8&255]^s[255&f]^r[u++],
// Update state
h=_,l=y,f=g,d=v;
// Shift rows, sub bytes, add round key
_=(c[h>>>24]<<24|c[l>>>16&255]<<16|c[f>>>8&255]<<8|c[255&d])^r[u++],y=(c[l>>>24]<<24|c[f>>>16&255]<<16|c[d>>>8&255]<<8|c[255&h])^r[u++],g=(c[f>>>24]<<24|c[d>>>16&255]<<16|c[h>>>8&255]<<8|c[255&l])^r[u++],v=(c[d>>>24]<<24|c[h>>>16&255]<<16|c[l>>>8&255]<<8|c[255&f])^r[u++];
// Set output
t[e]=_,t[e+1]=y,t[e+2]=g,t[e+3]=v},keySize:8}),F=(
/**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
w.AES=p._createHelper(u),i),p2=(w=F.lib).WordArray,w=w.BlockCipher,p=F.algo,_2=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],y2=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],g2=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],v2=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],B2=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],w2=p.DES=w.extend({_doReset:function(){for(
// Shortcuts
var t=this._key.words,e=[],r=0;r<56;r++){var i=_2[r]-1;e[r]=t[i>>>5]>>>31-i%32&1}
// Assemble 16 subkeys
for(var n=this._subKeys=[],o=0;o<16;o++){
// Select 48 bits according to PC2
for(
// Create subkey
var s=n[o]=[],c=g2[o],r=0
// Shortcut
;r<24;r++)
// Select from the left 28 key bits
s[r/6|0]|=e[(y2[r]-1+c)%28]<<31-r%6,
// Select from the right 28 key bits
s[4+(r/6|0)]|=e[28+(y2[r+24]-1+c)%28]<<31-r%6;
// Since each subkey is applied to an expanded 32-bit input,
// the subkey can be broken into 8 values scaled to 32-bits,
// which allows the key to be used without expansion
s[0]=s[0]<<1|s[0]>>>31;for(r=1;r<7;r++)s[r]=s[r]>>>4*(r-1)+3;s[7]=s[7]<<5|s[7]>>>27}
// Compute inverse subkeys
for(var a=this._invSubKeys=[],r=0;r<16;r++)a[r]=n[15-r]},encryptBlock:function(t,e){this._doCryptBlock(t,e,this._subKeys)},decryptBlock:function(t,e){this._doCryptBlock(t,e,this._invSubKeys)},_doCryptBlock:function(t,e,r){
// Get input
this._lBlock=t[e],this._rBlock=t[e+1],
// Initial permutation
k2.call(this,4,252645135),k2.call(this,16,65535),m2.call(this,2,858993459),m2.call(this,8,16711935),k2.call(this,1,1431655765);
// Rounds
for(var i=0;i<16;i++){for(
// Shortcuts
var n=r[i],o=this._lBlock,s=this._rBlock,c=0,a=0;a<8;a++)c|=v2[a][((s^n[a])&B2[a])>>>0];this._lBlock=s,this._rBlock=o^c}
// Undo swap from last round
var h=this._lBlock;this._lBlock=this._rBlock,this._rBlock=h,
// Final permutation
k2.call(this,1,1431655765),m2.call(this,8,16711935),m2.call(this,2,858993459),k2.call(this,16,65535),k2.call(this,4,252645135),
// Set output
t[e]=this._lBlock,t[e+1]=this._rBlock},keySize:2,ivSize:2,blockSize:2});
/**
	     * AES block cipher algorithm.
	     */
// Swap bits across the left and right words
function k2(t,e){e=(this._lBlock>>>t^this._rBlock)&e;this._rBlock^=e,this._lBlock^=e<<t}function m2(t,e){e=(this._rBlock>>>t^this._lBlock)&e;this._lBlock^=e,this._rBlock^=e<<t}
/**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */F.DES=w._createHelper(w2),p=p.TripleDES=w.extend({_doReset:function(){
// Shortcuts
var t=this._key.words;
// Make sure the key length is valid (64, 128 or >= 192 bit)
if(2!==t.length&&4!==t.length&&t.length<6)throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
// Extend the key according to the keying options defined in 3DES standard
var e=t.slice(0,2),r=t.length<4?t.slice(0,2):t.slice(2,4),t=t.length<6?t.slice(0,2):t.slice(4,6);
// Create DES instances
this._des1=w2.createEncryptor(p2.create(e)),this._des2=w2.createEncryptor(p2.create(r)),this._des3=w2.createEncryptor(p2.create(t))},encryptBlock:function(t,e){this._des1.encryptBlock(t,e),this._des2.decryptBlock(t,e),this._des3.encryptBlock(t,e)},decryptBlock:function(t,e){this._des3.decryptBlock(t,e),this._des2.encryptBlock(t,e),this._des1.decryptBlock(t,e)},keySize:6,ivSize:2,blockSize:2}),
/**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */
F.TripleDES=w._createHelper(p);
// Shortcuts
var u=i,F=u.lib.StreamCipher,w=u.algo,S2=w.RC4=F.extend({_doReset:function(){for(
// Shortcuts
var t=this._key,e=t.words,r=t.sigBytes,i=this._S=[],n=0;n<256;n++)i[n]=n;
// Key setup
for(var n=0,o=0;n<256;n++){var s=n%r,s=e[s>>>2]>>>24-s%4*8&255,o=(o+i[n]+s)%256,s=i[n];i[n]=i[o],i[o]=s}
// Counters
this._i=this._j=0},_doProcessBlock:function(t,e){t[e]^=x2.call(this)},keySize:8,ivSize:0});function x2(){for(
// Shortcuts
var t=this._S,e=this._i,r=this._j,i=0,n=0;n<4;n++){
// Swap
var r=(r+t[e=(e+1)%256])%256,o=t[e];t[e]=t[r],t[r]=o,i|=t[(t[e]+t[r])%256]<<24-8*n}
// Update counters
return this._i=e,this._j=r,i}
/**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */function b2(){
// Save old counter values
for(
// Shortcuts
var t=this._X,e=this._C,r=0;r<8;r++)c[r]=e[r];
// Calculate new counter values
e[0]=e[0]+1295307597+this._b|0,e[1]=e[1]+3545052371+(e[0]>>>0<c[0]>>>0?1:0)|0,e[2]=e[2]+886263092+(e[1]>>>0<c[1]>>>0?1:0)|0,e[3]=e[3]+1295307597+(e[2]>>>0<c[2]>>>0?1:0)|0,e[4]=e[4]+3545052371+(e[3]>>>0<c[3]>>>0?1:0)|0,e[5]=e[5]+886263092+(e[4]>>>0<c[4]>>>0?1:0)|0,e[6]=e[6]+1295307597+(e[5]>>>0<c[5]>>>0?1:0)|0,e[7]=e[7]+3545052371+(e[6]>>>0<c[6]>>>0?1:0)|0,this._b=e[7]>>>0<c[7]>>>0?1:0;
// Calculate the g-values
for(r=0;r<8;r++){var i=t[r]+e[r],n=65535&i,o=i>>>16;
// Construct high and low argument for squaring
// High XOR low
a[r]=((n*n>>>17)+n*o>>>15)+o*o^((4294901760&i)*i|0)+((65535&i)*i|0)}
// Calculate new state values
t[0]=a[0]+(a[7]<<16|a[7]>>>16)+(a[6]<<16|a[6]>>>16)|0,t[1]=a[1]+(a[0]<<8|a[0]>>>24)+a[7]|0,t[2]=a[2]+(a[1]<<16|a[1]>>>16)+(a[0]<<16|a[0]>>>16)|0,t[3]=a[3]+(a[2]<<8|a[2]>>>24)+a[1]|0,t[4]=a[4]+(a[3]<<16|a[3]>>>16)+(a[2]<<16|a[2]>>>16)|0,t[5]=a[5]+(a[4]<<8|a[4]>>>24)+a[3]|0,t[6]=a[6]+(a[5]<<16|a[5]>>>16)+(a[4]<<16|a[4]>>>16)|0,t[7]=a[7]+(a[6]<<8|a[6]>>>24)+a[5]|0}
/**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */function A2(){
// Save old counter values
for(
// Shortcuts
var t=this._X,e=this._C,r=0;r<8;r++)f[r]=e[r];
// Calculate new counter values
e[0]=e[0]+1295307597+this._b|0,e[1]=e[1]+3545052371+(e[0]>>>0<f[0]>>>0?1:0)|0,e[2]=e[2]+886263092+(e[1]>>>0<f[1]>>>0?1:0)|0,e[3]=e[3]+1295307597+(e[2]>>>0<f[2]>>>0?1:0)|0,e[4]=e[4]+3545052371+(e[3]>>>0<f[3]>>>0?1:0)|0,e[5]=e[5]+886263092+(e[4]>>>0<f[4]>>>0?1:0)|0,e[6]=e[6]+1295307597+(e[5]>>>0<f[5]>>>0?1:0)|0,e[7]=e[7]+3545052371+(e[6]>>>0<f[6]>>>0?1:0)|0,this._b=e[7]>>>0<f[7]>>>0?1:0;
// Calculate the g-values
for(r=0;r<8;r++){var i=t[r]+e[r],n=65535&i,o=i>>>16;
// Construct high and low argument for squaring
// High XOR low
d[r]=((n*n>>>17)+n*o>>>15)+o*o^((4294901760&i)*i|0)+((65535&i)*i|0)}
// Calculate new state values
t[0]=d[0]+(d[7]<<16|d[7]>>>16)+(d[6]<<16|d[6]>>>16)|0,t[1]=d[1]+(d[0]<<8|d[0]>>>24)+d[7]|0,t[2]=d[2]+(d[1]<<16|d[1]>>>16)+(d[0]<<16|d[0]>>>16)|0,t[3]=d[3]+(d[2]<<8|d[2]>>>24)+d[1]|0,t[4]=d[4]+(d[3]<<16|d[3]>>>16)+(d[2]<<16|d[2]>>>16)|0,t[5]=d[5]+(d[4]<<8|d[4]>>>24)+d[3]|0,t[6]=d[6]+(d[5]<<16|d[5]>>>16)+(d[4]<<16|d[4]>>>16)|0,t[7]=d[7]+(d[6]<<8|d[6]>>>24)+d[5]|0}
/**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */return u.RC4=F._createHelper(S2),w=w.RC4Drop=S2.extend({
/**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */
cfg:S2.cfg.extend({drop:192}),_doReset:function(){S2._doReset.call(this);
// Drop
for(var t=this.cfg.drop;0<t;t--)x2.call(this)}}),
/**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */
u.RC4Drop=F._createHelper(w),u=(p=i).lib.StreamCipher,F=p.algo,o=[],c=[],a=[],F=F.Rabbit=u.extend({_doReset:function(){
// Swap endian
for(
// Shortcuts
var t=this._key.words,e=this.cfg.iv,r=0;r<4;r++)t[r]=16711935&(t[r]<<8|t[r]>>>24)|4278255360&(t[r]<<24|t[r]>>>8);
// Generate initial state values
// Iterate the system four times
for(var i=this._X=[t[0],t[3]<<16|t[2]>>>16,t[1],t[0]<<16|t[3]>>>16,t[2],t[1]<<16|t[0]>>>16,t[3],t[2]<<16|t[1]>>>16],n=this._C=[t[2]<<16|t[2]>>>16,4294901760&t[0]|65535&t[1],t[3]<<16|t[3]>>>16,4294901760&t[1]|65535&t[2],t[0]<<16|t[0]>>>16,4294901760&t[2]|65535&t[3],t[1]<<16|t[1]>>>16,4294901760&t[3]|65535&t[0]],r=
// Carry bit
this._b=0
// Generate initial counter values
;r<4;r++)b2.call(this);
// Modify the counters
for(r=0;r<8;r++)n[r]^=i[r+4&7];
// IV setup
if(e){
// Shortcuts
var e=e.words,o=e[0],e=e[1],o=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),e=16711935&(e<<8|e>>>24)|4278255360&(e<<24|e>>>8),s=o>>>16|4294901760&e,c=e<<16|65535&o;
// Modify counter values
n[0]^=o,n[1]^=s,n[2]^=e,n[3]^=c,n[4]^=o,n[5]^=s,n[6]^=e,n[7]^=c;
// Iterate the system four times
for(r=0;r<4;r++)b2.call(this)}},_doProcessBlock:function(t,e){
// Shortcut
var r=this._X;
// Iterate the system
b2.call(this),
// Generate four keystream words
o[0]=r[0]^r[5]>>>16^r[3]<<16,o[1]=r[2]^r[7]>>>16^r[5]<<16,o[2]=r[4]^r[1]>>>16^r[7]<<16,o[3]=r[6]^r[3]>>>16^r[1]<<16;for(var i=0;i<4;i++)
// Swap endian
o[i]=16711935&(o[i]<<8|o[i]>>>24)|4278255360&(o[i]<<24|o[i]>>>8),
// Encrypt
t[e+i]^=o[i]},blockSize:4,ivSize:2}),p.Rabbit=u._createHelper(F),p=(w=i).lib.StreamCipher,u=w.algo,h=[],f=[],d=[],u=u.RabbitLegacy=p.extend({_doReset:function(){
// Iterate the system four times
for(
// Shortcuts
var t=this._key.words,e=this.cfg.iv,r=this._X=[t[0],t[3]<<16|t[2]>>>16,t[1],t[0]<<16|t[3]>>>16,t[2],t[1]<<16|t[0]>>>16,t[3],t[2]<<16|t[1]>>>16],i=this._C=[t[2]<<16|t[2]>>>16,4294901760&t[0]|65535&t[1],t[3]<<16|t[3]>>>16,4294901760&t[1]|65535&t[2],t[0]<<16|t[0]>>>16,4294901760&t[2]|65535&t[3],t[1]<<16|t[1]>>>16,4294901760&t[3]|65535&t[0]],n=
// Carry bit
this._b=0;n<4;n++)A2.call(this);
// Modify the counters
for(n=0;n<8;n++)i[n]^=r[n+4&7];
// IV setup
if(e){
// Shortcuts
var t=e.words,e=t[0],t=t[1],e=16711935&(e<<8|e>>>24)|4278255360&(e<<24|e>>>8),t=16711935&(t<<8|t>>>24)|4278255360&(t<<24|t>>>8),o=e>>>16|4294901760&t,s=t<<16|65535&e;
// Modify counter values
i[0]^=e,i[1]^=o,i[2]^=t,i[3]^=s,i[4]^=e,i[5]^=o,i[6]^=t,i[7]^=s;
// Iterate the system four times
for(n=0;n<4;n++)A2.call(this)}},_doProcessBlock:function(t,e){
// Shortcut
var r=this._X;
// Iterate the system
A2.call(this),
// Generate four keystream words
h[0]=r[0]^r[5]>>>16^r[3]<<16,h[1]=r[2]^r[7]>>>16^r[5]<<16,h[2]=r[4]^r[1]>>>16^r[7]<<16,h[3]=r[6]^r[3]>>>16^r[1]<<16;for(var i=0;i<4;i++)
// Swap endian
h[i]=16711935&(h[i]<<8|h[i]>>>24)|4278255360&(h[i]<<24|h[i]>>>8),
// Encrypt
t[e+i]^=h[i]},blockSize:4,ivSize:2}),w.RabbitLegacy=p._createHelper(u),i});